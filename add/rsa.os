// Источник http://maintenance.kz/?q=node/9
// немного переделано, не работает

Функция ЧислоВМассив(Знач Ч)
	М = Новый Массив;
	М.Добавить(Ч);
	П = 0;
	Пока Ч > 999 Цикл
		Ч1 = Цел (Ч / 1000);
		М.Добавить(Ч1);
		М.Установить(П, Ч - Ч1 * 1000);
		П = П + 1;
		Ч = Ч1;
	КонецЦикла;
	Возврат М;
КонецФункции // ЧислоВМассив(Ч)

Функция МассивВЧисло(М)
	Ч = 0;
	П = М.Количество() - 1;
	Пока НЕ П < 0 Цикл
		Ч = Ч + М.Получить(П) * Pow(1000, П);
		П = П - 1;
	КонецЦикла;
	Возврат Ч;
КонецФункции // МассивВЧисло(М)

Функция ВычестьМ(М1, М2)

	М = Новый Массив;
	П1 = М1.Количество() - 1;
	П2 = М2.Количество() - 1;
	П = 0;
	О = 0;
	Пока П <= П2 ИЛИ П <= П1 Цикл
		З = -О;
		О = 0;
		Если П <= П1 Тогда
			З = З + М1.Получить(П);
		КонецЕсли;
		Если П <= П2 Тогда
			З = З - М2.Получить(П);
		КонецЕсли;
		Пока З < - 999 Цикл
			З = З + 1000;
			О = О + 1;
		КонецЦикла;
		М.Добавить(З);
		П = П + 1;
	КонецЦикла;
	Если НЕ О = 0 Тогда
		М.Добавить(-О);
	КонецЕсли;
	Возврат М;

КонецФункции // ВычестьМ(М1, М2)

Функция СложитьМ(М1, М2)

	М = Новый Массив;
	П1 = М1.Количество() - 1;
	П2 = М2.Количество() - 1;
	П = 0;
	О = 0;
	Пока П <= П2 ИЛИ П <= П1 Цикл
		З = О;
		О = 0;
		Если П <= П1 Тогда
			З = З + М1.Получить(П);
		КонецЕсли;
		Если П <= П2 Тогда
			З = З + М2.Получить(П);
		КонецЕсли;
		Пока З > 999 Цикл
			З = З - 1000;
			О = О + 1;
		КонецЦикла;
		М.Добавить(З);
		П = П + 1;
	КонецЦикла;
	Если НЕ О = 0 Тогда
		М.Добавить(О);
	КонецЕсли;
	Возврат М;

КонецФункции // СложитьМ(М1, М2)

Функция УмножитьМ(М1, М2)

	М = Новый Массив;
	П1 = М1.Количество() - 1;
	П2 = М2.Количество() - 1;
	П11 = 0;
	П = - 1;
	Пока П11 <= П1 Цикл
		П22 = 0;
		О = 0;
		Пока П22 <= П2 Цикл
			З = О + М1.Получить(П11) * М2.Получить(П22);
			О = Цел(З / 1000);
			З = З - О * 1000;
			Если П11 + П22 > П Тогда
				М.Добавить(З);
				П = П11 + П22;
			Иначе
				З = М.Получить(П11 + П22) + З;
			КонецЕсли;
			Пока З > 999 Цикл
				З = З - 1000;
				О = О + 1;
			КонецЦикла;
			М.Установить(П11 + П22, З);
			П22 = П22 + 1;
		КонецЦикла;
		П11 = П11 + 1;
		Если НЕ О = 0 Тогда
			Если П11 + П22 > П Тогда
				М.Добавить(О);
				П = П11 + П22;
			Иначе
				М.Установить(П11 + П22, М.Получить(П11 + П22) + О);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Возврат М;

КонецФункции // УмножитьМ(М1, М2)

Функция Степень(знОсн, знПок)
	//Возврат знОсн;
	Осн = Число(знОсн);
	Пок = Число(знПок);
	Рез = Осн;
	Пока Пок > 1 Цикл
		Рез = Рез * Осн;
		Пок = Пок - 1;
	КонецЦикла;
	Возврат Рез;
КонецФункции // Степень()

Функция СтрокуВСтруктуру(Знач Стр)
	Стр = СтрРазделить(Стр, Символы.Таб);
	Ключ = Неопределено;
	Рез = Неопределено;
	Для Каждого знСтр Из Стр Цикл
		Если Ключ = Неопределено Тогда
			Ключ = знСтр;
		Иначе
			Если Рез = Неопределено Тогда
				Рез = Новый Структура;
			КонецЕсли;
			Рез.Вставить(Ключ, знСтр);
			Ключ = Неопределено;
		КонецЕсли;
	КонецЦикла;
	Возврат Рез;
КонецФункции

Функция СтруктуруВСтроку(Структ)
	Результат = "";
	Если НЕ Структ = Неопределено Тогда
		Для каждого Элемент Из Структ Цикл
			Результат = ?(Результат = "", "", Результат + Символы.Таб) + Элемент.Ключ + Символы.Таб + Элемент.Значение;
		КонецЦикла;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Функция проверяет является ли проверяемое число простым.
// Тест простоты (Перебор делителей).
// Параметры:
// 	- натуральное число.
// Возврат:
// 	- ИСТИНА - если число является простым.
Функция ТестПростоты(ЧислоДляПроверки)
	Индекс = 2;
	Признак = 0;
	Пока ((Индекс * Индекс) <= ЧислоДляПроверки) Цикл
		Если ЧислоДляПроверки%Индекс = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Функция возвращает случайное простое число в заданном диапазоне.
// Параметры:
// 	- НижнийДиапазон - нижняя граница диапазона;
// 	- ВерхнийДиапазон - верхняя граница диапазона.
// Возврат:
// 	- случайное простое число.
Функция ПолучитьПростоеЧисло(НижнийДиапазон, ВерхнийДиапазон, НачальноеЗначение)
	ГСЧ = Новый ГенераторСлучайныхЧисел(НачальноеЗначение);
	СлучайноеЧисло = ГСЧ.СлучайноеЧисло(НижнийДиапазон, ВерхнийДиапазон);
	Пока Не ТестПростоты(СлучайноеЧисло) Цикл
		СлучайноеЧисло = ГСЧ.СлучайноеЧисло(НижнийДиапазон, ВерхнийДиапазон);
	КонецЦикла;
	НачальноеЗначениеи = ГСЧ.СлучайноеЧисло(НижнийДиапазон, ВерхнийДиапазон);
	Возврат СлучайноеЧисло;
КонецФункции

// Функция вычсляет взаимно простое число к заданному числу (Алгоритм Евклида).
// Параметры:
// 	- ЧислоОснова - число являющееся основой для поиска взаимно простых чисел.
// 	- ЧислоПоиска - число от которого начинается поиск взаимно простого числа.
// Возврат:
// 	- структура с взаимно простым числом и обратное число по модулю.
Функция ПолучитьВзаимноПростыеЧисла(ЧислоОснова, ЧислоПоиска)
	СтруктураВозврата = Новый Структура;

	Пока ЧислоПоиска < ЧислоОснова Цикл
		НаибольшийОбщийДелитель = 0;
		Делимое = ЧислоОснова;
		Делитель = ЧислоПоиска;
		Остаток = ЧислоПоиска;

		// Из соотношения Безу.
		АльфаМинус2 = 1;
		АльфаМинус1 = 0;

		ВитаМинус2 = 0;
		ВитаМинус1 = 1;

		Пока Остаток > 0 Цикл
			Частное = Делимое/Делитель;
			Остаток = Делимое - Делитель * Цел(Частное);

			Альфа = АльфаМинус2 - Цел(Частное) * АльфаМинус1;
			Вита = ВитаМинус2 - Цел(Частное) * ВитаМинус1;

			Если Остаток > 0 Тогда
				Делимое = Делитель;
				Делитель = Остаток;
			Иначе
				НаибольшийОбщийДелитель = Делитель;
			КонецЕсли;

			АльфаМинус2 = АльфаМинус1;
			АльфаМинус1 = Альфа;

			ВитаМинус2 = ВитаМинус1;
			ВитаМинус1 = Вита;
		КонецЦикла;

		Если НаибольшийОбщийДелитель = 1 И ВитаМинус2 > 0 Тогда //
			СтруктураВозврата.Вставить("НОД", ЧислоПоиска);
			СтруктураВозврата.Вставить("Вита", ВитаМинус2);

			Возврат СтруктураВозврата;
		КонецЕсли;

		ЧислоПоиска = ЧислоПоиска + 1;
	КонецЦикла;

	Возврат ПолучитьВзаимноПростыеЧисла(ЧислоОснова, Цел(ЧислоПоиска/2));

КонецФункции


// Функция формирует закрытый и открытый ключ.
// Возврат:
// 	- структура с набором ключей, открытый-(e, n) и закрытый-(d, n).
Функция СформироватьКлючи() Экспорт

	// Управление разрядностью ключа
	ВерхняяГраница = 30;
	НижняяГраница = 10;

	// p
	ЧастьПи = ПолучитьПростоеЧисло(НижняяГраница, ВерхняяГраница, 0);
	// q
	ЧастьКью = ЧастьПи;
	Пока ЧастьКью = ЧастьПи Цикл
		ЧастьКью = ПолучитьПростоеЧисло(НижняяГраница, ВерхняяГраница, 0);
	КонецЦикла;

	// n
	ЧастьЭн = ЧастьПи * ЧастьКью;


	// Вычисляем функцию Эйлера.
	ЗначениеЭйлера = (ЧастьПи - 1) * (ЧастьКью - 1);

	// Вычисляем случайное взаимно простое чисело.
	ГСЧ = Новый ГенераторСлучайныхЧисел(ЗначениеЭйлера);
	СлучайноеЧисло = ГСЧ.СлучайноеЧисло(1, ЗначениеЭйлера);

	// e, d
	СтруктураЗначений = ПолучитьВзаимноПростыеЧисла(ЗначениеЭйлера, СлучайноеЧисло);
	ЧастьЕ = СтруктураЗначений.НОД;
	ЧастьД = СтруктураЗначений.Вита;

	// Собираем готовые ключи
	СтруктураВозврата = Новый Структура;
	СтруктураКлюча = Новый Структура;
	СтруктураКлюча.Вставить("ЧастьЕ", ЧастьЕ);
	СтруктураКлюча.Вставить("ЧастьЭн", ЧастьЭн);
	СтруктураВозврата.Вставить("ОткрытыйКлюч", СтруктуруВСтроку(СтруктураКлюча));
	СтруктураКлюча = Новый Структура;
	СтруктураКлюча.Вставить("ЧастьЭн", ЧастьЭн);
	СтруктураКлюча.Вставить("ЧастьД", ЧастьД);
	СтруктураВозврата.Вставить("ЗакрытыйКлюч", СтруктуруВСтроку(СтруктураКлюча));

	Возврат СтруктураВозврата;

КонецФункции


// Функция шифрует текст с использованием открытого ключа.
// Параметры:
// 	- текст подлежащий шифрованию;
// 	- открытый ключ.
// Возврат:
// 	- шифротекст в виде строки чисел через ";".
Функция Шифрование(СтрокаСимволов, ОткрытыйКлюч) Экспорт
	СтрокаВозврата = "";
	СтруктураКлюча = СтрокуВСтруктуру(ОткрытыйКлюч);

	МассивСимволов = СтрРазделить(СтрокаСимволов, ";");
	Для Каждого Код ИЗ МассивСимволов Цикл
		Если НЕ Код = "" Тогда
			Степень = Степень(Код, СтруктураКлюча.ЧастьЕ);
			Шифрокод = Степень - СтруктураКлюча.ЧастьЭн * Цел(Степень / СтруктураКлюча.ЧастьЭн);

			СтрокаВозврата = СтрокаВозврата + Шифрокод + ";"
		КонецЕсли;
	КонецЦикла;

	Возврат СтрокаВозврата;

КонецФункции


// Функция дешифрует текст с использованием закрытого ключа.
// Параметры:
// 	- шифротекст;
// 	- закрытый ключ.
// Возврат:
// 	- дешифрованный текст.
Функция Дешифрование(Шифротекст, ЗакрытыйКлюч) Экспорт
	СтрокаВозврата = "";
	СтруктураКлюча = СтрокуВСтруктуру(ЗакрытыйКлюч);

	СтрШифрокод = "";
	Для Индекс = 1 По СтрДлина(Шифротекст) Цикл
		Если Сред(Шифротекст, Индекс, 1) = ";" Тогда
			Шифрокод = Число(СтрШифрокод);
			Степень = Степень(Шифрокод, СтруктураКлюча.ЧастьД);
			Код = Степень - СтруктураКлюча.ЧастьЭн * Цел(Степень / СтруктураКлюча.ЧастьЭн);

			СтрокаВозврата = СтрокаВозврата + Код + ";";
			СтрШифрокод = "";
		Иначе
			Если Не Сред(Шифротекст, Индекс, 1) = " " Тогда
				СтрШифрокод = СтрШифрокод + Сред(Шифротекст, Индекс, 1);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Возврат СтрокаВозврата;

КонецФункции

Функция Закодировать(ШифруемыйТекст) Экспорт
	СтрокаВозврата = "";

	Для Индекс = 1 По СтрДлина(ШифруемыйТекст) Цикл
		Код = КодСимвола(ШифруемыйТекст, Индекс);
		СтрокаВозврата = СтрокаВозврата + Код + ";"
	КонецЦикла;

	Возврат СтрокаВозврата;

КонецФункции

Функция Раскодировать(СтрокаСимволов) Экспорт
	СтрокаВозврата = "";

	МассивСимволов = СтрРазделить(СтрокаСимволов, ";");
	Для Каждого Код ИЗ МассивСимволов Цикл
		Если НЕ Код = "" Тогда
			СтрокаВозврата = СтрокаВозврата + Символ(Код);
		КонецЕсли;
	КонецЦикла;

	Возврат СтрокаВозврата;

КонецФункции

ч1 = 99999999;
м1 = ЧислоВМассив(ч1);

ч2 = 99999999;
м2 = ЧислоВМассив(ч2);

м3 = УмножитьМ(м1,м2);
ч3 = МассивВЧисло(м3);

//ч11 = МассивВЧисло(СложитьМ(м2,м3));

Сообщить(ч1);
Сообщить(ч2);
Сообщить((ч1 * ч2));
Сообщить(ч3);
Сообщить((ч3 = ч1 * ч2));

// Ключи1 = СформироватьКлючи();
// Ключи2 = СформироватьКлючи();
//
// Сообщить(Ключи1.ОткрытыйКлюч);
// Сообщить(Ключи1.ЗакрытыйКлюч);
//
// зн = Закодировать("123");
//
// Сообщить(зн);
// ш1 = Шифрование(зн, Ключи1.ОткрытыйКлюч);
// Сообщить(ш1);
// ш2 = Шифрование(ш1, Ключи2.ОткрытыйКлюч);
// Сообщить(ш2);
//
// д2 = Дешифрование(ш2, Ключи2.ЗакрытыйКлюч);
// д1 = Дешифрование(ш1, Ключи1.ЗакрытыйКлюч);
//
// зн1 = Раскодировать(д1);
// Сообщить(зн1);
